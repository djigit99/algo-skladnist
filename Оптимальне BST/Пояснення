Постановка задачі:
Побудувати оптимальне бінарне дерево пошуку.

Вхідні данні:
Число n - кількість вершин у дереві. (Ei)
Далі йдуть частоти запитів вершин: f(E1), f(E2), ..., f(En);

Вихідні данні:
Вартість оптимального бінарного дерева пошуку.

Розв'язок:
Задачу вирішено метод динамічного програмування (динаміка на відрізках, L-R динаміка).
Опишемо масив dp[i][j] - оптимальне бінарне дерево пошуку(ОБДП) з елементів на відрізку [i, j].
База динаміки: 
	ОБДП з одного елементу завжди буде 0, тому dp[i][i] = 0, для всіх iє[0, n - 1]. (індексація з 0)
Перехід:
	Нехай нам відомо значення dp[i][j], тоді уже відомі і значення dp[i1][j1], де i <= i1 <= j1 <= j.
	Знайдемо значення dp[i][j+1].
		Для цього переберемо всі елементи в інтервалі [i,j+1]. 
			Зафіксуємо елемент k. Припустимо, що k - корінь ОБДП на [i, j + 1].
			Тоді вартість цього ОБДП буде dp[i][k - 1](зміщене на рівень вниз) + dp[k+1][j+1](зміщене на рівень вниз).
			Як перерахувати вартість ОБДП, зміщене на рівень вниз ?
				Нехай у нас є ОБДП, яке складається з елементів E1, E2, ..., En. Тоді його вартість дорівнює:
				f(E1) * cost(E1) + f(E2) * cost(E2) + ... + f(En) * cost(En).
				Коли змістимо на рівень нижче, вартість стане:
				f(E1) * (cost(E1) + 1) + f(E2) * (cost(E2) + 1) + ... + f(En) * (cost(En) + 1) = 
				f(E1) * cost(E1) + f(E1) + f(E2) * cost(E2) + f(E2) + ... + f(En) * cost(En) + f(En) = 
				f(E1) * cost(E1) + f(E2) * cost(E2) + ... + f(En) * cost(En) + (f(E1) + f(E2) + ... + f(En)).
			З'язувавши, маємо:
			Вартість ОБДП = dp[i][k-1] + s[k-1] - s[i-1] + dp[k+1][j+1] + s[j+1] - s[k], де s - масив часткових сум f(Ei),
												s[i] - сумма значень f, на [0,i].
		Перебравши всі k на [i,j+1], знайдемо мінімальне значення ОБДП (min_cost) і присвоїмо dp[i][j+1] = min_cost.
Відвовідь: 
	dp[0][n-1].
